# H-MOCA 스마트 카트: 기술 문서
* 작성일: 2019년 8월 18일
* 작성자: 박수성


## 1. 하드웨어 설계
H-MOCA 카트는 메카넘 휠 4개, 엔코더가 장착된 DC 모터 4개, HC-SR04 초음파 센서 5개, Raspberry Pi 3B 1대, 그리고 Arduino 3대를 장착하고 있다. 차체는 가공이 용이한 아크릴 재질로 제작되었다. 카트를 자동으로 결합하고 탈거하는 메커니즘은 스테인리스 스틸로 제작되었으며, 확인된 최고 하중은 15kg이다.

각각의 바퀴의 속도는 PID 방식으로 제어되며, 제어 목표값을 설정하기 위해서는 지면의 카트에 대한 상대속도를 계산하는 기구학 방정식을 풀어야 한다.

### 1.1. 기계 설계
본 프로젝틀 수행함에 있어, 가장 치수를 맞추기 어렵고, 또 구하기 어려웠던 부품은 메카넘 휠이었다. 따라서 기계를 설계함에 있어 메카넘 휠의 직경을 가장 먼저 결정하였고, 다른 부품들을 이에 맞추어 설계하였다.

우선, 구동부가 최대 15kg 가량의 하중을 이동시킬 수 있고, 기울기 10도 가량의 경사로를 등판할 수 있도록 하는 목표치를 설정하였다. 이에 요구되는 추진력을 다음과 같이 계산하였다.

$$ mg \sin{\theta}
    = 15 \textnormal{kg} \times 9.8 \textnormal{m/s}^2 \times \sin{10 \degree}
    = 25.55 \textnormal{N} = 2.604 \textnormal{kgf} $$

합리적인 가격에 구입할 수 있는 메카넘 휠의 직경의 종류는 40mm, 65mm, 100mm, 200mm 등으로 제한적이었는데, 이 중 위에서 계산한 추진력을 내기 위해 필요한 모터를 가장 합리적인 가격으로 선택할 수 있는 것은 직경이 100mm인 메카넘 휠이었다. 이러한 다각도의 고려를 통해 결정한 구동부의 사양은 아래와 같다.

* 바퀴: $\phi 100$ 메카넘 휠 4개
* 모터: 기어비 1:19, 정격 토크 $4.1 \text{kgf} \cdot \text{cm}$ 모터 4개

구동부의 사양을 결정한 이후, 카트의 차체를 설계하였다. 차체가 비대해져 무게가 너무 많이 나가지 않도록, 전자 부품과 배터리를 가능한 한 차체 내부로 은닉할 수 있도록, 그리고 센서의 데이터 수집에 방해가 되지 않도록 고려하였다. 설계 도면은 [이 링크](https://drive.google.com/ "Google Drive로 연결")에서 확인할 수 있다.

카트 설계가 완료된 후, 카트를 차량에 자동으로 탈부착하는 메커니즘을 설계하였다. 설계 초기에는 평행사변형 4절 링크, 리니어 액추에이터, 180도 이상 회전하는 6절 링크 등 다양한 구동 방식이 제시되었으나, 최종적으로 평행사변형 4절 링크가 채택되었다. 링크의 모습은 아래 그림과 같다.

그림

한 가지 고려할 사항이 있었는데, 메커니즘이 지면에 근접한 때에는 카트가 메커니즘 내부로 진입하여야 하므로 카트와 지면의 접촉이 유지되어야 하고, 차량에 결합되었을 때에는 카트가 메커니즘으로부터 미끄러지지 않도록 카트와 트렁크 바닥면이 접촉하지 않아야 한다는 점이었다. 따라서, 이러한 사항을 고려하여 각 링크의 길이를 지정하였다. 또한, 메커니즘이 상승하는 과정에 트렁크 바닥면과 카트가 간섭하지 않도록 안쪽의 링크 두 개의 끝 부분을 둥글게 제작하였다. 각 링크의 설계 도면은 [이 링크](https://drive.google.com/ "Google Drive로 연결")에서 확인할 수 있다.

메커니즘을 구동하기 위해서는 한 쌍의 리니어 액추에이터가 필요한데, 한 팀원이 보유하고 있던 리니어 액추에이터가 적합한 성능을 가지고 있어 사용하였고, 비용을 절감하였다.


### 1.2. 전자 하드웨어 설계
카트에는 4대의 임베디드 보드 및 SBC 가 사용되었다. 상세한 내용은 아래와 같다.

* Raspberry Pi 3B 1대
* Arduino Mega 2560 1대
* Arduino Uno R3 2대

이 중, Raspberry Pi는 중앙 제어와 각 보드 간의 통신, 그리고 카메라 데이터 처리를 담당하고, Arduino Mega 2560은 구동부를 PID 방식으로 제어하며, Arduino Uno R3는 초음파 센서 데이터를 처리하고 전송한다.

한편, 카트에는 다수의 센서가 사용되었는데, 상세한 내용은 아래와 같다.

* HC-SR04 초음파 센서 5대
* Microsoft LifeCam HD-3000 1대
* Microsoft LifeCam Cinema 1대

초음파 센서는 거리 측정을 담당하고, LifeCam HD-3000은 전방에 부착되어 사람을 추적하며, LifeCam Cinema는 측면에 부착되어 메커니즘과 결합 시 ArUco 마커를 추적한다. 사람을 추적하는 카메라는 화질보다는 이미지 처리 속도가 중요한 반면, 마커를 추적하는 카메라는 처리 속도보다는 화질이 중요하기 떄문에, 이에 맞추어 예산을 분배하여 구입하였다.
***


## 2. 소프트웨어 설계
### 2.1. Robot Operating System
H-MOCA 카트는 다수의 구동 장치와 센서 등이 부착되므로, 이들 장치 간의 원활한 통신이 매우 중요하다. 이를 구현하기 위해, 전 세계에서 가장 널리 사용되는 오픈소스 로봇 소프트웨어 프레임워크인 ROS (Robot Operating System)을 사용하였으며, 총 6개의 프로그램이 동시에 실행되며 서로 통신한다. 이들 프로그램은 카트에 장착된 Raspberry Pi 상에서 구동된다. ROS에 관한 자세한 내용은 [이 링크](http://wiki.ros.org/ROS/Tutorials)에서 확인할 수 있다.


### 2.2. 하드웨어 별 기능 분배
4개의 모터는 PID 방식으로 제어되기 때문에, 각 모터마다 회전 방향과 회전 속도를 조절하는 핀 각각 한 개 씩, 그리고 엔코더 클럭에 해당하는 핀 두 개 등 총 4개의 GPIO 핀이 필요하다. 사용 가능한 GPIO 핀이 12개인 Arduino Uno로는 신호를 모두 주고받을 수 없기 때문에, 더 많은 수의 핀을 가진 Arduino Mega 2560 보드를 사용하였다.

한편, Raspberry Pi와 Arduino는 시리얼 통신으로 통신하는데, Raspberry Pi 상에서 구동되는 프로그램과 Arduino 내에서 구동되는 스케치 모두 무한 루프 내에서 데이터 통신과 처리가 이루어지므로, 빠른 전송 속도를 확보하는 것이 매우 중요하다. 그런데, Arduino IDE에서 기본으로 제공하는 `Serial.println(int)` 메서드를 그대로 사용할 경우, 각각의 자릿수가 문자로 변환되어 통신이 비효율적이게 된다. 이렇게 하는 대신, 시리얼 통신을 위한 버퍼를 할당하고, 원래의 자료형에 맞도록 바이트 형식으로 인코딩하여 전송하면 통신 용량이 줄어든다. 예를 들어, `int` 형 변수 `0xFFFFFFFF`는 10진법으로 -2,147,483,648에 해당하는데, 숫자 열 개와 부호 한 개를 전송할 경우 총 11바이트를 전송해야 하지만, `int` 형 바이너리로 인코딩하여 전송할 경우 `int`형 변수의 크기인 4바이트만큼만 전송하면 된다. 따라서, 모든 통신은 이러한 방법으로 인코딩을 거친다. 각 하드웨어의 시리얼 통신용 프로토콜은 아래와 같다.

* 모터 제어용 Arduino Mega 2560
  * RPi -> Arduino: (모터 속도: short) x 4 + (EOL: char) x 1 = 9 bytes
  * Arduino -> RPi: (지난 번 보고 이후 흐른 시간: unsigned int) x 1 + (엔코더 증분: short) x 4 + (EOL: char) x 1 = 13 bytes
* 초음파 센서 제어용 Arduino Uno R3
  * RPi -> Arduino: (\x06) + (EOL: char) x 1 = 2 bytes
  * Arduino -> RPi: (측정 거리: short) x 4 + (EOL: char) x 1 = 9 bytes

### 2.3. PID 제어 구현
Arduino 보드는 클럭 주파수가 낮아 각 연산의 처리 속도가 다소 불규칙적으로 변할 수 있다. 따라서, 일반적인 로봇 제어에서 무한루프의 주기를 일정하도록 인위적으로 조절하는 것과는 달리, 루프의 각 회차를 시작할 때마다 시간을 기록하고, 이를 이용하여 제어 값들을 계산하였다. 계산 수식은 아래와 같다.

$$ \frac{de}{dt} \approx \frac{e_{t+1} - e_t}{T_{t+1} - T_t} $$
$$ \int_0^T{e\ dt} \approx \sum_{i=1}^N{\frac{e_{i+1} + e_i}{2} \cdot (t_{i+1} - t_i)} $$

위의 수식에서. 아래첨자 $t+1$ 은 현재 회차에서 새로이 측정한 값이고, $t$ 는 이전 회차에서 측정하였던 값이다. 현재 회차의 명령이 모두 실행된 후, $t+1$에 해당하는 데이터가 $t$ 에 해당하는 데이터를 덮어씌우게 된다. 이러한 방식으로 구현된 코드는 [박수성 팀원의 GitHub](https://github.com/platinum78/porterble/blob/master/arduino_firmware/driver/pid_controller.h)에서 확인할 수 있다.

### 2.4. 인트라넷 Wi-Fi의 구성
H-MOCA 카트는 자율주행과 자동 결합 기능을 탑재하고 있기는 하지만, 적어도 각 동작을 시작할 때만큼은 사용자의 명령을 받아야 한다. 따라서, 사용자의 스마트폰이 카트와 동일한 네트워크에 연결되어 있어야 한다. 이를 위헤, 중앙 제어에 사용되는 Raspberry Pi의 무선랜 어댑터를 핫스팟으로 사용할 수 있도록 하는 `hostapd` 프로그램과 DHCP 작업을 자동으로 수행해 주는 `dhcpcd` 프로그램을 사용하였다. 이 프로그램은 대부분의 리눅스 배포판에서 설치 가능하며, Debian 계열에서는 `sudo apt install hostapd dhcpcd` 를 실행하여 설치할 수 있다. 설정 사항은 아래와 같다.

* IP: `192.168.4.1`
* DHCP Range: `192.168.4.2 - 21`
* Network Interface: `wlan0` (Raspberry Pi 내장 무선랜의 이름)

### 2.5. HTTP Listener 서버의 구축
ROS 프레임워크는 TCP 통신을 사용하나, HTTP 통신과 직접 호환되지는 않는다. 따라서, 사용자의 스마트폰으로부터 명령을 받아 실행할 수 있도록 하기 위해, ROS와 연동되는 별도의 HTTP 서버를 구축하였다. 서버는 특정 URL을 인식하여 ROS 네트워크로 전달하는데, 각 URL의 구성은 아래와 같다.

* `/changeMode?mode=follow/`: 자동 따라오기 모드로 전환
* `/changeMode?mode=manual/`: 수동 조작 모드로 전환
* `/changeMode?mode=docking/`: 자동 도킹 모드로 전환
* `/manualMove?dir={direction}&speed={speed}/`: 수동 조작 모드 시, 원하는 방향과 속도로 카트를 이동

사용자 어플리케이션은 상기한 네 가지의 URL을 작성하여 HTTP 요청을 보내게 된다. 사용자 어플리케이션에 대한 설명을 아래에서 제시한다.

### 2.6. Android 어플리케이션 제작
사용자가 명령을 전송할 수 있도록 하기 위해, 간단한 Android용 어플리케이션을 제작하였다. 빠른 Prototyping을 위해 공식 IDE인 안드로이드 스튜디오 대신 MIT App Inventor를 사용하였다. 해당 프로젝트는 [박수성 팀원의 GitHub](https://github.com/platinum78/porterble/blob/master/misc/porterble.aia)에서 확인할 수 있다.

***


## 3. 추가 정보
모든 코드는 [박수성 팀원의 GitHub](https://github.com/platinum78/porterble)에서 확인할 수 있다.